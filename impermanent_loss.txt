Impermanent Loss and Breakeven Analysis for PancakeSwap V3 Concentrated Liquidity Positions
This document provides a comprehensive guide to implementing impermanent loss (IL) calculations and breakeven time analysis for PancakeSwap V3 positions, based on Uniswap V3 mechanics (as PancakeSwap V3 is a fork of Uniswap V3). The calculations are tailored to the data from your app's output, such as initial and current token amounts, price ranges, initial price, USD values, APR, and rewards. All formulas assume:

Token0 = cbBTC (volatile token, denoted as A).
Token1 = USDC (stable token, denoted as B, assumed $1 USD per USDC).
Price P = token1 / token0 = USDC per cbBTC (large number, e.g., 112828).
Position is staked in a farm, earning CAKE rewards and swap fees.
Research confirms: PancakeSwap V3 follows Uniswap V3 for concentrated liquidity and IL. Out-of-range positions do not earn CAKE rewards or swap fees (only in-range liquidity earns). Thus, breakeven assumes the position stays in-range to earn at the current APR.

Key Variables from App Output
Extract these from your app's position data:

price_lower: Lower price bound (Pa, e.g., 109461 USDC per cbBTC).
price_upper: Upper price bound (Pb, e.g., 116229 USDC per cbBTC).
price_initial: Initial price at deposit (P0, e.g., 112828 USDC per cbBTC).
amount_a_initial: Initial amount of token0 (cbBTC, e.g., 0.00116125).
amount_b_initial: Initial amount of token1 (USDC, e.g., 134.245342).
initial_usd_value: Initial position value in USD (e.g., 265.27).
amount_a_current: Current amount of token0 (cbBTC, e.g., 0.0009676).
amount_b_current: Current amount of token1 (USDC, e.g., 156.148).
current_usd_value: Current position value in USD (e.g., 265.32, excluding uncollected fees).
apr: Estimated APR (e.g., 125.86%, including fees + CAKE rewards).
time_elapsed_seconds: Time position has been open in seconds (e.g., parse "2h/48m/0s" to 10080 seconds).
total_rewards_accrued_usd: Total rewards accrued in USD (e.g., 0.1067, including CAKE + fees).

Note: Your app should fetch the current pool price (price_current) directly from the PancakeSwap V3 pool contract (via sqrtPriceX96, converted to P = (sqrtPriceX96 / 2^96)^2, adjusted for token order). If not available, compute it from current amounts using the quadratic formula below. Uncollected fees are excluded from IL calculations (IL focuses on principal divergence).
Step 1: Compute Liquidity (L) from Initial Data
L is the position's liquidity parameter. Compute using initial amounts and price.
Formulas (using sqrt prices for precision):

sa = sqrt(price_lower)
sb = sqrt(price_upper)
s0 = sqrt(price_initial)
L_from_a = amount_a_initial / (1/s0 - 1/sb)
L_from_b = amount_b_initial / (s0 - sa)
L = (L_from_a + L_from_b) / 2 (average if slight discrepancy due to rounding; ideally they match).

Implementation Tip: If discrepancy > 0.1%, log error (possible data rounding). Use math.sqrt in JS/Node.
Step 2: Compute Current Price (if not fetched from pool)
If price_current isn't directly available, solve quadratic from current amounts:

a_coef = amount_a_current
b_coef = (amount_b_current / sb) - (amount_a_current * sa)
c_coef = -amount_b_current
Discriminant d = b_coef^2 - 4 * a_coef * c_coef
s = [-b_coef + sqrt(d)] / (2 * a_coef) (positive root between sa and sb)
price_current = s^2

Validation: Ensure sa <= s <= sb (position in-range). Example from data: ~113391.
Step 3: Compute Current Impermanent Loss
IL = (Position value - Hold value) at current price, excluding fees/rewards.

Position value (lp_value) = amount_a_current * price_current + amount_b_current (your app already computes this as current_usd_value).
Hold value (hold_value) = amount_a_initial * price_current + amount_b_initial
il_dollar = lp_value - hold_value
il_percent = (il_dollar / hold_value) * 100

Notes:

IL is typically negative (loss).
If using computed price_current, validate against current_usd_value (e.g., recompute lp_value and compare; discrepancies may be due to rounding).

Step 4: Compute IL at High End (Price = price_upper)
At upper bound, position converts to all token1 (USDC).

s_upper = sb (from Step 1)
If price >= price_upper: amount_a_at_upper = 0
amount_b_at_upper = L * (s_upper - sa)
lp_value_upper = amount_a_at_upper * price_upper + amount_b_at_upper
hold_value_upper = amount_a_initial * price_upper + amount_b_initial
il_dollar_upper = lp_value_upper - hold_value_upper
il_percent_upper = (il_dollar_upper / hold_value_upper) * 100

Edge Case: At exact upper bound, position is at edge of range; assume IL as above.
Step 5: Compute IL at Low End (Price = price_lower)
At lower bound, position converts to all token0 (cbBTC).

s_lower = sa (from Step 1)
If price <= price_lower: amount_b_at_lower = 0
amount_a_at_lower = L * (1/s_lower - 1/sb)
lp_value_lower = amount_a_at_lower * price_lower + amount_b_at_lower
hold_value_lower = amount_a_initial * price_lower + amount_b_initial
il_dollar_lower = lp_value_lower - hold_value_lower
il_percent_lower = (il_dollar_lower / hold_value_lower) * 100

Step 6: Compute Breakeven Time to Offset IL
Breakeven time = time to earn back |IL| via rewards at current APR, assuming position stays in-range (out-of-range earns nothing).

Use initial_usd_value as base for APR (consistent with how APR is estimated).
Yearly rewards = (apr / 100) * initial_usd_value
Rewards per second = yearly_rewards / (365.25 * 24 * 3600)  // Use 365.25 for leap years
For high end: time_seconds_upper = Math.abs(il_dollar_upper) / rewards_per_second
For low end: time_seconds_lower = Math.abs(il_dollar_lower) / rewards_per_second

Format Time: Convert seconds to "Xw/Xd/Xh/Xm/Xs" (weeks/days/hours/minutes/seconds).

weeks = Math.floor(seconds / (7 * 24 * 3600))
days = Math.floor((seconds % (7*86400)) / 86400)
hours = Math.floor((seconds % 86400) / 3600)
minutes = Math.floor((seconds % 3600) / 60)
secs = seconds % 60
String: ${weeks}w/${days}d/${hours}h/${minutes}m/${secs}s (omit zero units if desired).

Alternative Rate Calculation (more precise if using accrued data):

rewards_per_second = total_rewards_accrued_usd / time_elapsed_seconds
Then use this instead (matches APR extrapolation).

Notes:

APR includes fees + CAKE; assumes constant rate while in-range.
If position goes out-of-range, breakeven doesn't apply (no earnings).
For boundaries, breakeven assumes earnings at rate before hitting boundary.

Implementation Tips in Node.js

Use BigNumber from bignumber.js or ethers.js for precision (avoid float errors with sqrts/large numbers).
Fetch current price via Web3/ethers from pool contract: sqrtPriceX96 = await poolContract.slot0() then price = (BigInt(sqrtPriceX96) ** 2n / (1n << 192n)).toNumber() (adjust for decimals/token order; cbBTC likely 8 decimals, USDC 6).
Error Handling: If position out-of-range, IL calculations still apply, but warn user earnings stop.
Testing: Use example data to verify (e.g., current IL ~ -0.029%, high IL ~ -0.76%, low IL ~ -1.18%; times depend on APR).
Research Sources: Formulas derived from Uniswap V3 whitepaper, Medium articles on V3 IL, arXiv paper (2111.09192), and PancakeSwap docs (v3 farms only reward in-range).